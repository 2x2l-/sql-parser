<?xml version="1.0"?>
<!DOCTYPE project SYSTEM "build.dtd">
<project name="parser" default="all" basedir=".">

  <property file="build.properties.local"/>
  <property file="build.properties"/>

  <property name="SRC" location="src/main/java"/>
  <property name="CLASSES" value="classes"/>
  <property name="GRAMMAR" location="${SRC}/com/akiban/sql/parser/SQLGrammar.jj"/>
  <property name="JAR" value="parser-combined.jar"/>

  <path id="compiler.class.path">
    <pathelement path="${AKIBAN_SERVER_CLASSPATH}"/>
  </path>

  <target name="all" depends="init, compile, jar"
          description="Compile everything."/>

  <target name="init">
    <tstamp/>
    <mkdir dir="${CLASSES}"/>
  </target>

  <target name="compile">
    <javacc javacchome="${JAVACC_HOME}"
            target="${GRAMMAR}"/>
    <javac srcdir="${SRC}" 
           destdir="${CLASSES}"
           includes="**/*.java" 
           deprecation="yes"
           includeantruntime="false"
           debug="${DEBUG}">
      <classpath>
        <path refid="compiler.class.path"/>
      </classpath>
    </javac>
  </target> 

  <target name="jar" depends="compile">
    <copy file="${AKIBAN_SERVER_CLASSPATH}" tofile="${JAR}"/>
    <jar destfile="${JAR}" update="true">
      <fileset dir="${CLASSES}"/>
    </jar>
  </target> 

  <target name="dtd" depends="init"
          description="Create DTD file.">
    <antstructure output="build.dtd"/>
  </target>

  <path id="running.class.path">
    <pathelement path="${JAR}"/>
  </path>

  <target name="enableJavaDebugger" if="JDWP_PORT">
    <property name="JAVA_DEBUGGER"
              value="-Xdebug -Xrunjdwp:server=y,suspend=y,transport=dt_socket,address=${JDWP_PORT}"/>
  </target>

  <target name="jvmargs" depends="enableJavaDebugger">
    <property name="JAVA_DEBUGGER" value=""/>
    <property name="JVMARGS" value="${JAVA_DEBUGGER}"/>
  </target>

  <target name="test-parser" depends="compile, jvmargs">
    <java classname="com.akiban.sql.test.Tester" fork="yes" failonerror="yes">
      <classpath refid="running.class.path"/>
      <arg line="-tree"/>
      <arg value="SELECT x,y FROM t WHERE z > 3.14 AND w IS NOT NULL"/>
      <arg value="INSERT INTO t1 VALUES(1, 'foo', 3 * 10)"/>
      <arg value="INSERT INTO t1 SELECT x,y,z FROM t"/>
      <arg value="CREATE TABLE t2 AS (SELECT * FROM t1) WITH NO DATA"/>
      <arg value="DELETE FROM t WHERE x in (1,2,3)"/>
      <arg value="SELECT x,y FROM t WHERE z IN (SELECT z FROM w WHERE q > 10)"/>
      <arg value="SELECT * FROM (SELECT z,y FROM t1) AS s"/>
      <arg value="SELECT * FROM t1 WHERE EXISTS ((VALUES 1) INTERSECT (VALUES 2))"/>
      <arg value="CREATE VIEW v1(x,y) AS (SELECT y,z FROM t1 WHERE y IS NOT NULL)"/>
      <arg value="SELECT * FROM t1,t2 LEFT OUTER JOIN t3 ON t2.x = t3.x RIGHT OUTER JOIN t4 ON t3.x = t4.x"/>
    </java>
  </target> 

  <target name="test-unparser" depends="compile, jvmargs">
    <java classname="com.akiban.sql.test.Tester" fork="yes" failonerror="yes">
      <classpath refid="running.class.path"/>
      <arg line="-print"/>
      <arg value="SELECT x,y||y AS yy FROM t WHERE z > 3.14 AND w IS NOT NULL OR y LIKE 'f%'"/>
      <arg value="SELECT DISTINCT MAX(x),y||y AS yy FROM t WHERE z > 3.14 AND w IS NOT NULL OR y LIKE 'f%' GROUP BY yy HAVING yy > 'z' ORDER BY yyo NULLS FIRST"/>
      <arg value="SELECT x,y FROM t WHERE z BETWEEN 1 AND 10"/>
      <arg value="SELECT CASE WHEN x = y OR x = z THEN x WHEN y = z THEN y ELSE w END FROM t"/>
      <arg value="SELECT CAST(x AS DECIMAL(4,2)) FROM t"/>
      <!--
      <arg value="INSERT INTO t1(x,y,z) VALUES(1, X'DEADBEEF', 3 * 10)"/>
      <arg value="INSERT INTO t1 SELECT x,y,z FROM t"/>
      <arg value="DELETE FROM t t1 WHERE x in (1,2,?) AND EXISTS (SELECT * FROM t t2 WHERE t1.id &lt;> t2.id AND t1.name = t2.name)"/>
      <arg value="UPDATE t SET x = null, y = y + 1 WHERE x &lt;= 4"/>
      <arg value="CREATE TABLE t1 (i int PRIMARY KEY, s char(30) NOT NULL, z VARCHAR(128))"/>
      <arg value="CREATE TABLE t2 AS (SELECT * FROM t1) WITH DATA"/>
      -->
      <arg value="SELECT * FROM t1 LEFT OUTER JOIN t2 on t1.id = t2.xid RIGHT OUTER JOIN t3 on t1.id = t3.yid INNER JOIN t4 USING (a,b,c)"/>
      <arg value="SELECT * FROM (SELECT z,y FROM t1) AS s"/>
      <arg value="CREATE VIEW v1(x,y) AS (SELECT y,z FROM t1 WHERE y IS NOT NULL)"/>
    </java>
  </target> 

  <target name="test-clone" depends="compile, jvmargs">
    <java classname="com.akiban.sql.test.Tester" fork="yes" failonerror="yes">
      <classpath refid="running.class.path"/>
      <arg line="-print -clone -print"/>
      <arg value="SELECT x + y + z FROM t1 WHERE x > 0 AND y > 'foo'"/>
    </java>
  </target> 

  <target name="test-binder" depends="compile, jvmargs">
    <java classname="com.akiban.sql.test.Tester" fork="yes" failonerror="yes">
      <classpath refid="running.class.path"/>
      <arg value="-bind"/>
      <arg value="CREATE TABLE t1(x INT NOT NULL, y VARCHAR(7), z DECIMAL); CREATE table t2(w CHAR(1) NOT NULL);"/>
      <arg line="-types -tree"/>
      <arg value="SELECT x + y + z FROM t1 WHERE x > 0 AND y > 'foo'"/>
      <arg value="SELECT x,y FROM t1,t2 AS tt WHERE t1.y > tt.w"/>
      <arg value="SELECT CASE WHEN x = 10 THEN y WHEN x = 20 THEN 3 ELSE z END FROM t1"/>
      <arg value="SELECT COALESCE(x,z) FROM t1"/>
      <arg value="SELECT x, x2 FROM t1, (SELECT x AS not_x, y AS x2 FROM t1) AS t2"/>
      <arg value="SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t2)"/>
    </java>
  </target> 

  <target name="test-normalizer" depends="compile, jvmargs">
    <java classname="com.akiban.sql.test.Tester" fork="yes" failonerror="yes">
      <classpath refid="running.class.path"/>
      <arg line="-boolean -print"/>
      <arg value="SELECT * FROM t WHERE a = 1"/>
      <arg value="SELECT * FROM t WHERE ((a AND b) AND c) AND NOT d"/>
      <arg value="SELECT * FROM t WHERE (d OR e) OR ((a AND b) AND c)"/>
      <arg value="SELECT * FROM t1 LEFT OUTER JOIN t2 ON t1.id = t2.pid"/>
    </java>
  </target> 
   
  <target name="test-views" depends="compile, jvmargs">
    <java classname="com.akiban.sql.test.Tester" fork="yes" failonerror="yes">
      <classpath refid="running.class.path"/>
      <arg value="-bind"/>
      <arg value="CREATE TABLE t1(x INT NOT NULL, y VARCHAR(7), z DECIMAL); CREATE table t2(w CHAR(1) NOT NULL);"/>
      <arg value="-view"/>
      <arg value="CREATE VIEW v1(x,y) AS SELECT y,z FROM t1 WHERE y IS NOT NULL"/>
      <arg line="-print -tree"/>
      <arg value="SELECT x FROM v1 WHERE y > 'foo'"/>
    </java>
  </target> 

  <target name="test-flattener" depends="compile, jvmargs">
    <java classname="com.akiban.sql.test.Tester" fork="yes" failonerror="yes">
      <classpath refid="running.class.path"/>
      <arg value="-bind"/>
      <arg value="CREATE TABLE parent(id INT, PRIMARY KEY(id), name VARCHAR(256) NOT NULL, UNIQUE(name)); CREATE TABLE child(id INT, PRIMARY KEY(id), pid INT, CONSTRAINT `__akiban_fk0` FOREIGN KEY akibanfk(pid) REFERENCES parent(id), name VARCHAR(256) NOT NULL);"/>
      <arg value="-view"/>
      <arg value="CREATE VIEW names(pname,cname) AS SELECT parent.name,child.name FROM parent,child WHERE parent.id = child.pid"/>
      <arg line="-boolean -types -flatten -print-bound"/>
      <arg value="SELECT name FROM child WHERE pid IN (SELECT parent.id FROM parent WHERE parent.name = 'foo')"/>
      <arg value="SELECT name FROM child WHERE pid = ANY (SELECT parent.id FROM parent WHERE parent.name = 'foo')"/>
      <arg value="SELECT name FROM child WHERE pid > ANY (SELECT parent.id FROM parent WHERE parent.name = 'foo')"/>
      <arg value="SELECT name FROM child WHERE pid > ANY (SELECT parent.id FROM parent WHERE parent.name > 'foo')"/>
      <arg value="SELECT name FROM child WHERE pid IN (SELECT parent.id FROM parent,child WHERE parent.name = 'foo')"/>
      <arg value="SELECT name FROM child WHERE pid IN (SELECT parent.id FROM parent,child c2 WHERE parent.name = 'foo' AND parent.id = c2.pid AND c2.id = 1)"/>
      <!-- child condition can be much more interesting with EXISTS JOIN -->
      <arg value="SELECT name FROM parent p WHERE EXISTS (SELECT * from child c WHERE c.pid = p.id AND c.id = 3)"/>
      <arg value="SELECT pname,cname FROM names WHERE pname = 'foo'"/>
    </java>
  </target> 

  <target name="test-grouper" depends="compile, jvmargs">
    <java classname="com.akiban.sql.test.Tester" fork="yes" failonerror="yes">
      <classpath refid="running.class.path"/>
      <arg value="-bind"/>
      <arg value="CREATE TABLE parent(id INT, PRIMARY KEY(id), name VARCHAR(256) NOT NULL, UNIQUE(name), state CHAR(2)); CREATE TABLE child(id INT, PRIMARY KEY(id), pid INT, CONSTRAINT `__akiban_fk0` FOREIGN KEY akibanfk(pid) REFERENCES parent(id), name VARCHAR(256) NOT NULL);"/>
      <arg value="-view"/>
      <arg value="CREATE VIEW names(pname,cname) AS SELECT parent.name,child.name FROM parent,child WHERE parent.id = child.pid"/>
      <arg line="-boolean -types -flatten -group-rewrite -print"/>
      <arg value="SELECT parent.name,child.name FROM parent,child WHERE parent.state = 'MA'"/>
      <arg value="SELECT parent.name,child.name FROM parent,child WHERE child.pid = parent.id AND parent.state = 'MA'"/>
      <arg value="SELECT p1.name,child.name FROM parent AS p1,parent AS p2,child WHERE child.pid = p1.id AND p2.state = 'MA' AND p1.id &lt;> p2.id"/>
      <arg value="SELECT child.name FROM child WHERE pid IN (SELECT parent.id FROM parent WHERE state = 'MA')"/>
      <arg value="SELECT parent.name,child.name FROM parent INNER JOIN child ON child.pid = parent.id WHERE parent.state = 'MA'"/>
      <arg value="SELECT pname,cname FROM names WHERE pname = 'foo'"/>
    </java>
  </target> 

  <target name="test-postgres-server" depends="compile, jvmargs">
    <java classname="com.akiban.sql.pg.PostgresServerManager" fork="yes" failonerror="yes">
      <classpath refid="running.class.path"/>
    </java>
  </target>

  <path id="sql.class.path">
    <path refid="compiler.class.path"/>
    <pathelement path="${CLASSES}"/>
    <pathelement path="/usr/share/java/postgresql-jdbc3-8.4.jar"/>
  </path>

  <target name="test-sql-0" depends="compile, jvmargs">
    <java classname="com.akiban.sql.test.SQLClient" fork="yes" failonerror="yes">
      <classpath refid="sql.class.path"/>
      <arg value="org.postgresql.Driver"/>
      <arg value="jdbc:postgresql://daffy:5432/mmcm"/>
      <arg value="mmcm"/>
      <arg value="foo"/>
      <arg value="SELECT * FROM types"/>
    </java>
  </target> 

  <target name="test-sql-1" depends="compile, jvmargs">
    <java classname="com.akiban.sql.test.SQLClient" fork="yes" failonerror="yes">
      <classpath refid="sql.class.path"/>
      <arg value="org.postgresql.Driver"/>
      <arg value="jdbc:postgresql://daffy:15432/mmcm"/>
      <arg value="mmcm"/>
      <arg value="mmcm"/>
      <arg value="SELECT * FROM customers"/>
    </java>
  </target> 
  <target name="test-sql-2" depends="compile, jvmargs">
    <java classname="com.akiban.sql.test.SQLClient" fork="yes" failonerror="yes">
      <classpath refid="sql.class.path"/>
      <arg value="org.postgresql.Driver"/>
      <arg value="jdbc:postgresql://daffy:15432/mmcm"/>
      <arg value="mmcm"/>
      <arg value="mmcm"/>
      <arg value="SELECT * FROM t1 WHERE name > 'bar'"/>
    </java>
  </target> 
  <target name="test-sql-3" depends="compile, jvmargs">
    <java classname="com.akiban.sql.test.SQLClient" fork="yes" failonerror="yes">
      <classpath refid="sql.class.path"/>
      <arg value="org.postgresql.Driver"/>
      <arg value="jdbc:postgresql://daffy:15432/mmcm?ssm=true"/>
      <arg value="mmcm"/>
      <arg value="mmcm"/>
      <arg value="SELECT customers.name,order_date,sku,quan FROM customers,orders,items WHERE customers.cid = orders.cid AND orders.oid = items.oid AND items.sku &lt; '8888'"/>
    </java>
  </target> 
  <target name="test-sql-3a" depends="compile, jvmargs">
    <java classname="com.akiban.sql.test.SQLClient" fork="yes" failonerror="yes">
      <classpath refid="sql.class.path"/>
      <arg value="org.postgresql.Driver"/>
      <arg value="jdbc:postgresql://daffy:15432/mmcm?ssm=true"/>
      <arg value="mmcm"/>
      <arg value="mmcm"/>
      <arg value="SELECT customers.name,order_date,sku,quan FROM customers,orders,items WHERE customers.cid = orders.cid AND orders.oid = items.oid AND items.sku = '1234'"/>
    </java>
  </target> 
  <target name="test-sql-3b" depends="compile, jvmargs">
    <java classname="com.akiban.sql.test.SQLClient" fork="yes" failonerror="yes">
      <classpath refid="sql.class.path"/>
      <arg value="org.postgresql.Driver"/>
      <arg value="jdbc:postgresql://daffy:15432/mmcm?ssm=true"/>
      <arg value="mmcm"/>
      <arg value="mmcm"/>
      <arg value="SELECT customers.name,order_date,sku,quan FROM customers,orders,items WHERE customers.cid = orders.cid AND orders.oid = items.oid AND items.sku >= '0' AND items.sku &lt; '8888'"/>
    </java>
  </target> 
  <target name="test-sql-4" depends="compile, jvmargs">
    <java classname="com.akiban.sql.test.SQLClient" fork="yes" failonerror="yes">
      <classpath refid="sql.class.path"/>
      <arg value="org.postgresql.Driver"/>
      <arg value="jdbc:postgresql://daffy:15432/mmcm"/>
      <arg value="mmcm"/>
      <arg value="mmcm"/>
      <arg value="SELECT customers.name,order_date,sku,quan FROM customers,orders,items WHERE customers.cid = orders.cid AND orders.oid = items.oid AND items.sku &lt; ?"/>
      <arg value="888"/>
    </java>
  </target> 
  <target name="test-sql-5" depends="compile, jvmargs">
    <java classname="com.akiban.sql.test.SQLClient" fork="yes" failonerror="yes">
      <classpath refid="sql.class.path"/>
      <arg value="org.postgresql.Driver"/>
      <arg value="jdbc:postgresql://daffy:15432/mmcm?ssm=true"/>
      <arg value="mmcm"/>
      <arg value="mmcm"/>
      <arg value="SELECT customers.name,order_date,sku,quan FROM customers,orders,items WHERE customers.cid = orders.cid AND orders.oid = items.oid AND items.sku &lt; '8888' AND items.quan = 100"/>
    </java>
  </target> 

  <target name="clean">
    <delete dir="${CLASSES}"/>
    <delete file="${SRC}/com/akiban/sql/parser/SQLGrammar.java"/>
  </target>

  <target name="dist">
    <tar destfile="../parser.tar.gz" compression="gzip" 
         basedir="." excludes="${CLASSES}/**/*.class"/>
  </target>

</project>
